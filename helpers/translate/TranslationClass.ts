// Types
import type { GenericMessage, NestedObject, TranslateQueue, TranslateTask } from '../types'
import type { ChatCompletionMessageParam } from 'openai/resources/chat/index.mjs'

// Utils
import { delay, loadMessages, getContentToPath, ensureSameOrder, writeFile } from '../utils'
import OpenAI from 'openai'
import * as osPath from 'path'

// Data
const LOCALE_FOLDER = `../../messages`
const EN_MESSAGES = require(`../../messages/en.json`)

/**
 * Check if rate limit is configured in the .env file.
 */
const RATE_LIMIT_PER_MIN = Number(process.env.GPT_API_RATE_LIMIT_PER_MINUTE)
if (isNaN(RATE_LIMIT_PER_MIN)) {
	throw `Make sure to set .env value "GPT_API_RATE_LIMIT_PER_MINUTE". This defines how many times the OpenAI API will be hit per minute and spread the translation tasks accordingly. It must be a valid number.`
}

/**
 * Check if API key is configured in the .env file.
 */
const API_KEY = process.env.GPT_API_KEY
if (!API_KEY) {
	throw `Make sure to set .env value "GPT_API_KEY". This should be the OpenAI organization API key to access GPT.`
}

const openai = new OpenAI({
	apiKey: process.env.GPT_API_KEY
})

/**
 * Translate and
 *
 * @param source Source language file name (usually "en" for English)
 * @param target Target language file name
 * @param language Target language for prompt (usually "informal <language>")
 */
export default class TranslationClass {
	readonly source: string
	readonly target: string
	readonly language: string
	readonly skipDateInFileName: boolean
	readonly messages: {
		source: NestedObject
		target: NestedObject
	}
	private finishCallback?: () => void
	private queue: TranslateQueue
	private finished: boolean
	private rateLimit: {
		last: number
		delayInMs: number
		check: (extraDelay: number) => Promise<boolean>
	}

	constructor({
		source,
		target,
		language,
		skipDateInFileName = false,
		finishCallback
	}: {
		source: string
		target: string
		language: string
		skipDateInFileName?: boolean
		finishCallback?: () => void
	}) {
		this.source = source
		this.target = target
		this.language = language
		this.skipDateInFileName = skipDateInFileName
		this.finishCallback = finishCallback
		this.messages = {
			source: {},
			target: {}
		}
		this.queue = []
		this.finished = false
		this.rateLimit = {
			last: 0,
			delayInMs: (60 / RATE_LIMIT_PER_MIN) * 1000,
			check: async (extraDelay = 0) => {
				const current = performance.now()
				const difference = current - this.rateLimit.last

				// Delay if rate limit is at risk of being exceeded
				if (this.rateLimit.last && difference < this.rateLimit.delayInMs + extraDelay) {
					const duration = this.rateLimit.delayInMs + extraDelay - difference
					this.rateLimit.last = current + duration
					await delay(duration)
				} else {
					this.rateLimit.last = current
				}

				return true
			}
		}

		this.init()
	}

	async init() {
		const { LOCALE_SOURCE, LOCALE_TARGET } = await loadMessages(this.source, this.target)
		this.messages.source = LOCALE_SOURCE
		this.messages.target = LOCALE_TARGET

		// Update the language to whatever the user is using
		this.messages.target._meta.language = this.language

		this.generateTranslationQueue()
		this.processTranslationQueue()
	}

	async finishTranslation(interrupted = false): Promise<void> {
		if (this.finished) return
		this.finished = true

		// Set up & write to output file
		const date = new Date()
		const timestamp = `${date.getHours()}-${date.getMinutes()}-${date.getSeconds()}`
		const name = this.skipDateInFileName ? this.target : `${this.target}.${timestamp}`

		if (interrupted) {
			console.info(`Translation was interrupted! Writing output file "${name}" now...`)
		} else {
			console.info(`Translation completed! Writing output file "${name}" now...`)
		}

		try {
			writeFile(
				osPath.join(__dirname, `${LOCALE_FOLDER}/${name}.json`),
				ensureSameOrder(this.messages.source, this.messages.target)
			)
			console.info(`Finished. File is now available.`)
			if (this.finishCallback) {
				this.finishCallback()
			} else {
				process.exit()
			}
		} catch (error) {
			console.error(error)
			throw `Failed to write output file.`
		}
	}

	async processTranslationQueue() {
		const tasks = this.queue.length
		if (tasks) {
			console.info(`A total of ${tasks} translation tasks were found. Processing now...`)

			/**
			 * Check progress to update user on progress or finish translation.
			 *
			 * @param value Float (0-1) of the progress being made
			 */
			const checkProgress = (value: number): void => {
				if (value === 1) {
					this.finishTranslation()
					return
				} else {
					console.info(`Translation progresss... (${Math.round(value * 100)}%)`)
				}
			}

			/**
			 * In case an error occurs in the middle of the translation, we'll write a file with
			 * whatever was successful so not everything has to be redone.
			 */
			process.on(`exit`, () => {
				this.finishTranslation(true)
			})

			// Start processing translation queue
			const count = { total: 0, completed: 0 }
			/**
			 * Using "forEach" as it allows us to await the results for the individual task
			 */
			this.queue.forEach(async task => {
				count.total++
				const output = await this.runTranslationTask(task)
				this.setContentFromTask([...task.path], this.messages.target, output, task)
				count.completed++
				checkProgress(count.completed / count.total)
			})
		} else {
			console.info(
				`There were no missing translations found. No further action will be taken.`
			)
			if (this.finishCallback) {
				this.finishCallback()
			} else {
				process.exit()
			}
		}
	}

	/**
	 * Generate translations to be made based on the layout of the .json file (hardcoded to match)
	 */
	generateTranslationQueue() {
		/**
		 * Headers
		 */
		this.generateTranslationTask(
			[`header`, `message`],
			`The context of these translations are short game headers informing the player of the game state.`
		)
		this.generateTranslationTask(
			[`header`, `description`],
			`The context of these translations are short game header descriptions informing the player of the game state.`
		)

		/**
		 * Misc.
		 */
		this.generateTranslationTask(
			[`category`],
			`These are short category titles for game settings (KEEP THEM SHORT).`
		)
		this.generateTranslationTask([`placeholder`])
		this.generateTranslationTask([`language`])
		this.generateTranslationTask([`status`])
		this.generateTranslationTask(
			[`time`],
			`The context of these are vue-i18n compliant pluralization entries.`
		)
		this.generateTranslationTask(
			[`count`],
			`The context of these are vue-i18n compliant pluralization entries (KEEP THEM SHORT)`
		)
		this.generateTranslationTask(
			[`misc`],
			`The context behind these are typically buttons and columns.`
		)
		this.generateTranslationTask(
			[`month`, `short`],
			`These must be only 3 letter month abbreviations.`
		)
		this.generateTranslationTask([`perk`], `These are unlockable game perks.`)
		this.generateTranslationTask([`title`], `These are unlockable game titles.`)

		/**
		 * Card related
		 */
		this.generateTranslationTask(
			[`card`],
			`These are used in a web based Cards Against Humanity card game.`
		)
		this.generateTranslationTask(
			[`card`, `editor`],
			`These are used in a web based Cards Against Humanity card game.`
		)
		this.generateTranslationTask([`card`, `type`])
		this.generateTranslationTask(
			[`card`, `sets`],
			`These are used in a web based Cards Against Humanity card game.`
		)
		this.generateTranslationTask(
			[`card`, `sets`, `info`],
			`These are used in a web based Cards Against Humanity card game.`
		)
		this.generateTranslationTask(
			[`card`, `info`],
			`These are used in a web based Cards Against Humanity card game.`
		)
		this.generateTranslationTask(
			[`card`, `info`],
			`These are used in a web based Cards Against Humanity card game.`
		)

		/**
		 * Information messages
		 */
		this.generateTranslationTask([`info`])
		this.generateTranslationTask([`info`, `poolType`], `These are 8 Ball Pool ball types.`)
		this.generateTranslationTask(
			[`info`, `poolFoul`, `self`],
			`These are 8 Ball Pool ball foul messages.`
		)
		this.generateTranslationTask(
			[`info`, `poolFoul`, `other`],
			`These are 8 Ball Pool ball foul messages.`
		)
		this.generateTranslationTask(
			[`info`, `battleship`],
			`These are used in a web based Battleships game.`
		)
		this.generateTranslationTask([`info`, `about`])
		this.generateTranslationTask([`info`, `awaitingPurchaseConfirmation`])
		this.generateTranslationTask([`info`, `settings`, `redeemCode`])
		this.generateTranslationTask([`info`, `settings`, `experience`])
		this.generateTranslationTask([`info`, `settings`, `statistics`])
		this.generateTranslationTask([`info`, `settings`, `analytics`])
		this.generateTranslationTask([`info`, `settings`, `serverData`])
		this.generateTranslationTask([`info`, `settings`, `controlYourData`])
		this.generateTranslationTask([`info`, `settings`, `localStorage`])
		this.generateTranslationTask([`info`, `settings`, `myDevices`])
		this.generateTranslationTask([`info`, `settings`, `ads`])
		this.generateTranslationTask([`info`, `authentication`])
		this.generateTranslationTask([`info`, `authentication`, `login`])
		this.generateTranslationTask([`info`, `authentication`, `setup`])
		this.generateTranslationTask([`info`, `authentication`, `setupThreshold`])
		this.generateTranslationTask([`info`, `authentication`, `unlink`])
		this.generateTranslationTask([`info`, `authentication`, `unlinkSuccess`])
		this.generateTranslationTask([`info`, `authentication`, `transferStart`])
		this.generateTranslationTask([`info`, `authentication`, `transferConfirm`])
		this.generateTranslationTask([`info`, `authentication`, `transferSuccess`])
		this.generateTranslationTask([`info`, `authentication`, `logout`])
		this.generateTranslationTask([`info`, `authentication`, `logoutGlobally`])
		this.generateTranslationTask([`info`, `authentication`, `logoutSuccess`])
		this.generateTranslationTask([`info`, `authentication`, `relogin`])
		this.generateTranslationTask([`info`, `authentication`, `loginCode`])
		this.generateTranslationTask([`info`, `authentication`, `ready`])
		this.generateTranslationTask([`info`, `connection`])
		this.generateTranslationTask([`info`, `connection`, `header`])
		this.generateTranslationTask([`info`, `connection`, `content`])
		this.generateTranslationTask([`info`, `friend`])
		this.generateTranslationTask([`info`, `yacht`])
		this.generateTranslationTask(
			[`info`, `yacht`, `title`],
			`These are Yacht/Yahtzee gaming terminologies.`
		)
		this.generateTranslationTask(
			[`info`, `yacht`, `shortTitle`],
			`These are shortened Yacht/Yahtzee gaming terminologies. Turn words into numbers (e.g. "three" as "3"). Also use abbreviations whenever possible (e.g. "large" as "lg").`
		)
		this.generateTranslationTask(
			[`info`, `yacht`, `description`],
			`These are Yacht/Yahtzee gaming terminology descriptions.`
		)
		this.generateTranslationTask([`info`, `cards`], `These are card game related messages.`)
		this.generateTranslationTask(
			[`info`, `war`],
			`These are War card game related messages and actions.`
		)
		this.generateTranslationTask(
			[`info`, `cribbage`],
			`These are Cribbage board game related messages and actions.`
		)
		this.generateTranslationTask(
			[`info`, `cribbage`, `title`],
			`These are Cribbage board game related terminologies.`
		)
		this.generateTranslationTask(
			[`info`, `accountWarning`],
			`These are messages related to an account receiving a warning.`
		)
		this.generateTranslationTask(
			[`info`, `accountWarning`, `reason`],
			`These are reasons why a player might get warned.`
		)
		this.generateTranslationTask(
			[`info`, `accountWarning`, `punishment`],
			`These are punishments a player might received after being warned.`
		)
		this.generateTranslationTask(
			[`info`, `ginRummy`, `title`],
			`This translation is a Gin Rummy action or outcome.`
		)
		this.generateTranslationTask(
			[`info`, `ginRummy`],
			`This translation is a Gin Rummy action or outcome.`
		)
		const cribbageTypes = Object.keys(EN_MESSAGES[`info`][`cribbage`][`type`])
		for (const type of cribbageTypes) {
			const target = EN_MESSAGES[`info`][`cribbage`][`type`][type]
			if (target.title) {
				this.generateTranslationTask(
					[`info`, `cribbage`, `type`, type, `title`],
					`This translation is a Cribbage score title.`
				)
			}
			if (target.description) {
				this.generateTranslationTask(
					[`info`, `cribbage`, `type`, type, `description`],
					`This translation is a Cribbage score description.`
				)
			}
			if (target.playTitle) {
				this.generateTranslationTask(
					[`info`, `cribbage`, `type`, type, `playTitle`],
					`This translation is a Cribbage play score description. It is shown inside %{0} or %{1}. Example phrase in which it is used: "You get 2 points for %{0} and %{1}."`
				)
			}
			if (target.playDescription) {
				this.generateTranslationTask(
					[`info`, `cribbage`, `type`, type, `playDescription`],
					`This translation is a Cribbage score description if it were used in a play.`
				)
			}
		}

		/**
		 * Chat messsages
		 */
		this.generateTranslationTask(
			[`chat`, `UNIVERSAL`],
			`These are short informal chat messages.`
		)
		this.generateTranslationTask(
			[`chat`, `PRE_GAME`],
			`These are short informal chat messages.`
		)
		this.generateTranslationTask([`chat`, `GAME`], `These are short informal chat messages.`)
		this.generateTranslationTask(
			[`chat`, `POST_GAME`],
			`These are short informal chat messages.`
		)

		/**
		 * Match messsages
		 */
		this.generateTranslationTask([`match`], `These are game matchmaking related butons.`)
		this.generateTranslationTask(
			[`match`, `lobby`],
			`These are game match lobby button states.`
		)
		this.generateTranslationTask([`match`, `browser`], `These are game match list.`)
		this.generateTranslationTask(
			[`match`, `opponentFilter`],
			`These are filters that can be applied when matchmaking.`
		)
		this.generateTranslationTask([`match`, `matchmaking`], `These are game matchmaking states.`)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `publicMatches`],
			`This is a matchmaking setting.`
		)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `publicMatches`, `tooltip`],
			`This is a matchmaking setting tooltip.`
		)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `games`],
			`This is a matchmaking setting.`
		)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `games`, `tooltip`],
			`This is a matchmaking setting tooltip.`
		)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `opponentFilter`],
			`This is a matchmaking setting.`
		)
		this.generateTranslationTask(
			[`match`, `matchmaking`, `settings`, `opponentFilter`, `tooltip`],
			`This is a matchmaking setting tooltip.`
		)
		this.generateTranslationTask([`match`, `info`], `These are game match information.`)

		/**
		 * Error messsages
		 */
		this.generateTranslationTask([`error`, `rateLimit`])
		this.generateTranslationTask([`error`, `generic`])
		this.generateTranslationTask([`error`, `config`])
		this.generateTranslationTask([`error`, `start`])
		this.generateTranslationTask([`error`, `game`])
		this.generateTranslationTask([`error`, `card`])
		this.generateTranslationTask([`error`, `preset`])
		this.generateTranslationTask([`error`, `match`])
		this.generateTranslationTask([`error`, `profile`])
		this.generateTranslationTask([`error`, `requirement`])
		this.generateTranslationTask([`error`, `redeemCode`])
		this.generateTranslationTask(
			[`error`, `authentication`],
			`These are authentication related translations.`
		)

		/**
		 * Perk messages
		 */
		const perks = Object.keys(EN_MESSAGES[`perk`])
		for (const perk of perks) {
			const target = EN_MESSAGES[`perk`][perk]
			if (target.title) {
				this.generateTranslationTask(
					[`perk`, perk, `title`],
					`This translation is for an unlockable perk title.`
				)
			}
			if (target.description) {
				this.generateTranslationTask(
					[`perk`, perk, `description`],
					`This translation is for an unlockable perk description, with the title of "${target.title}".`
				)
			}
		}

		/**
		 * Game messages
		 */
		const heading = Object.keys(EN_MESSAGES[`game`])
		for (const value of heading) {
			const target = EN_MESSAGES[`game`][value]
			if (target.name) {
				this.generateTranslationTask(
					[`game`, value, `name`],
					`These translations are game names.`
				)
			}

			// Game preset
			const presets = Object.keys(target.presets)
			for (const title of presets) {
				this.generateTranslationTask([`game`, value, `presets`, title])
				const description = target.presets[title].description
				if (Array.isArray(description)) {
					this.generateTranslationTask([`game`, value, `presets`, title, `description`])
				}
			}

			// Game help
			const help = Object.keys(target.help)
			for (const title of help) {
				if (target.help[title].title) {
					this.generateTranslationTask(
						[`game`, value, `help`, title, `title`],
						`These translations must be a short game help tutorial title.`
					)
				}
				if (target.help[title].description) {
					this.generateTranslationTask([`game`, value, `help`, title, `description`])
				}
			}

			// Game options
			const options = Object.keys(target.options)
			for (const title of options) {
				if (target.options[title].title) {
					this.generateTranslationTask(
						[`game`, value, `options`, title, `title`],
						`These translations must be a short game settings option title.`
					)
				}
				if (target.options[title].help) {
					this.generateTranslationTask([`game`, value, `options`, title, `help`])
				}
				if (target.options[title].data) {
					this.generateTranslationTask([`game`, value, `options`, title, `data`])
				}
			}
		}
	}

	/**
	 * Mark a specific path as to be translated. Will look for any values with "null" to translate and skip
	 * over entries that have already been translated.
	 *
	 * @param path Path to the content to be translated
	 * @param description Additional description for the API when translating this context
	 */
	generateTranslationTask(path: string[], description?: string) {
		let type: TranslateTask[`type`] = `string`
		const input: string[] = []
		const inputKeys: string[] = []
		const source = getContentToPath([...path], this.messages.source)
		const target = getContentToPath([...path], this.messages.target, true)

		if (source === null) {
			const brokenPath = path.join(`, `)
			throw `Source came back as "null". The source should always have a string, array, or object! Please check the following path: "${brokenPath}"`
		} else if (typeof source === `string`) {
			type = `string`
			if (typeof target !== `string`) {
				input.push(source)
			}
		} else if (Array.isArray(source)) {
			type = `array`
			const _target = Array.isArray(target) ? target : []
			for (let i = 0; i < source.length; i++) {
				const sourceEntry = source[i]
				const targetEntry = _target[i]
				if (typeof sourceEntry === `string` && typeof targetEntry !== `string`) {
					input.push(sourceEntry)
				}
			}
		} else {
			type = `object`
			const _target = target && !Array.isArray(target) ? target : {}
			for (const id in source) {
				const sourceEntry = source[id]
				const targetEntry = _target[id]
				if (targetEntry == null)
					if (typeof sourceEntry === `string` && typeof targetEntry !== `string`) {
						input.push(sourceEntry)
						inputKeys.push(id)
					}
			}
		}

		/**
		 * Note to self: does it make sense to reduce the amount of API calls in and combining multiple entries
		 * in one? Or should each individual string have its own call?
		 */

		// If there were missing translations, make sure to queue this entry for translation
		if (input.length > 0) {
			// Make chunks of 5 lines max
			while (input.length > 0) {
				const list: string[] = []
				const target = input.splice(0, 5)
				const numbered = target.length > 1
				let inputCount = 0

				const addInput = (value: string) => {
					inputCount++
					const formattedValue = value.replace(/\n/g, `;;;;`)
					list.push(numbered ? `[${inputCount}] ${formattedValue}` : formattedValue)
				}

				for (const value of target) {
					addInput(value)
				}

				this.queue.push({
					type,
					path,
					input: list,
					inputKeys: inputKeys.splice(0, 5),
					description
				})
			}
		}
	}

	async runTranslationTask(task: TranslateTask): Promise<(string | null)[]> {
		const output = await this.translateText({
			input: task.input,
			description: task.description
		})

		if (!output) {
			console.error(`Failed to translate a task!`, task, ` - Output:`, output)
			process.exit(0)
		}

		return output
	}

	/**
	 * Hit the API with a request for translation.
	 *
	 * @param param0 Input array and optional description of what is being translated
	 * @param extraRateDelay In case an additional delay should be added before processing
	 * @param retries Keep track of the amount of retries have been attempted
	 * @returns Will give a sanitized output (matching input) or throw "false" in case of an error
	 */
	async translateText(
		{
			input,
			description
		}: {
			input: string[]
			description?: string
		},
		extraRateDelay = 0,
		retries = 0
	): Promise<false | string[]> {
		try {
			if (retries > 2) {
				console.error(`Failed to translate after 3 attempts.`, input, description)
				return false
			}

			// Check for rate limiting
			await this.rateLimit.check(extraRateDelay)

			/**
			 * Generate prompt for GPT-3 API. Language has been tweaked for best results.
			 *
			 * API sometimes messes up with larger lists, hence the request specifically mentions to start
			 * entries with a number. This allows us to validate the results more easily after as well.
			 *
			 * The results are still disappointing at times. It does require manual fixing.
			 */
			const messages: ChatCompletionMessageParam[] = [
				{
					role: `system`,
					content: `You are a game translation service. You will get a list of items you must translate to ${
						this.language
					} while preserving the order it was given in. Each entry will start with [number] followed by a string of text to be translated. If a single entry is given, it will not have this number. Keep things informal and easy to understand.${
						description ? ` ` + description : ``
					}`
				}
			]

			messages.push({
				role: `user`,
				content: input.join(`\n`)
			})

			const response = await openai.chat.completions.create({
				model: `gpt-4o-mini`,
				messages,
				temperature: 0,
				max_tokens: 2048,
				top_p: 1,
				frequency_penalty: 0,
				presence_penalty: 0
			})

			// Extract the translated text from the response
			const output = response.choices[0].message.content
			if (!output) {
				console.error(`Something went wrong with the output!`, response.choices)
				return false
			}
			return this.sanitiseOutput(input, output.split(`\n`))
		} catch (error) {
			// Check for rate limiting
			if (error && error.code === `rate_limit_exceeded`) {
				// Double the default delay for rate limit exceeding calls
				return this.translateText(
					{ input, description },
					this.rateLimit.delayInMs,
					retries++
				)
			} else {
				console.error(error.code)
				return false
			}
		}
	}

	/**
	 * Write the results of the API output to the target object.
	 *
	 * @param path Path to the content
	 * @param target Target object to write to
	 * @param content The content to be written
	 * @param task The translation task that resulted in this content
	 */
	setContentFromTask(
		path: string[],
		target: GenericMessage,
		content: (string | null)[],
		task: TranslateTask
	): boolean {
		const entry = path.splice(0, 1)[0]
		const _target = target[entry]

		// We have hit the end point; run checks!
		if (path.length === 0) {
			switch (task.type) {
				case `string`:
					target[entry] = content[0]
					return true
				case `array`:
					if (!Array.isArray(_target)) {
						target[entry] = content
					} else if (Array.isArray(_target)) {
						for (let i = 0; i < _target.length; i++) {
							if (_target[i] == null) {
								_target[i] = content.splice(0, 1)[0]
							}
						}
					}
					return true
				case `object`: {
					if (
						Array.isArray(target[entry]) ||
						target[entry] == null ||
						typeof target[entry] === `string`
					) {
						target[entry] = {}
					}
					const local = target[entry] as GenericMessage
					for (const key of task.inputKeys) {
						local[key] = content.splice(0, 1)[0]
					}
					return true
				}
				default:
					return false
			}
		} else if (_target === undefined) {
			throw `Cannot find entry "${entry}" from path "${path.join(
				`, `
			)}" in target translation file. Unable to set content: "${content.join(`, `)}".`
		}

		return this.setContentFromTask(path, _target as GenericMessage, content, task)
	}

	/**
	 * Using the input as reference, check and validate that the output makes sense. This
	 * is unfortunately necessary as the API can sometimes be a little inconsistent.
	 *
	 * @param input Input, original, messages
	 * @param output Output as returned by the API
	 * @returns Sanitized array or "false" in case of an error
	 */
	sanitiseOutput(input: string[], output: string[]): (string | null)[] | false {
		if (input.length > output.length) {
			console.error(`[NOTICE] Input list is longer than the output list!`, input, output)
			return Array(input.length).fill(null)
		}

		// Remove
		while (output.includes(``)) {
			output.splice(output.indexOf(``), 1)
		}

		/**
		 * If the output somehow got longer than the input, remove the difference.
		 *
		 * It's a bit of a naive approach; results should always be validated by a human.
		 */
		if (output.length > input.length) {
			output.splice(0, output.length - input.length)
		}

		if (input.length === output.length) {
			const processed: string[] = []
			if (input.length > 1) {
				output.forEach((entry, index) => {
					const expectedNumber = index + 1
					const regex = new RegExp(`\\[${expectedNumber}\\]`)
					if (regex.test(entry)) {
						let value = entry.replace(regex, ``).trim()
						value = value.replace(/\$;;;;/g, `\n`)
						processed.push(value)
					} else {
						console.error(
							`[NOTICE] Got invalid number sequence for entry "${entry}".`,
							input,
							output
						)
						return Array(input.length).fill(null)
					}
				})
			} else {
				const value = output[0].replace(/\$;;;;/g, `\n`)
				processed.push(value)
			}
			return processed
		} else {
			console.error(
				`[NOTICE] Unable to sanitise the output list (Output: ${output.length} - Input: ${input.length})`,
				input,
				output
			)
			return Array(input.length).fill(null)
		}
	}
}
